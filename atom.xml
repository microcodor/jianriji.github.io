<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>微码农</title>
  
  <subtitle>程序员工作笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://microcodor.github.io/"/>
  <updated>2019-05-07T08:47:54.000Z</updated>
  <id>https://microcodor.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ANR问题</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/ANR%E9%97%AE%E9%A2%98/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/ANR问题/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:47:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ANR"><a href="#ANR" class="headerlink" title="#ANR"></a>#ANR</h2><p>1、ANR排错一般有三种类型</p><ol><li>KeyDispatchTimeout(5 seconds) –主要是类型按键或触摸事件在特定时间内无响应</li><li>BroadcastTimeout(10 seconds) –BroadcastReceiver在特定时间内无法处理完成</li><li>ServiceTimeout(20 secends) –小概率事件 Service在特定的时间内无法处理完成</li></ol><p>2、哪些操作会导致ANR<br>在主线程执行以下操作：</p><ol><li>高耗时的操作，如图像变换</li><li>磁盘读写，数据库读写操作</li><li>大量的创建新对象</li></ol><p>3、如何避免</p><ol><li>UI线程尽量只做跟UI相关的工作</li><li>耗时的操作(比如数据库操作，I/O，连接网络或者别的有可能阻塞UI线程的操作)把它放在单独的线程处理</li><li>尽量用Handler来处理UIThread和别的Thread之间的交互</li></ol><p>4、解决的逻辑</p><ol><li>使用AsyncTask<ol><li>在doInBackground()方法中执行耗时操作</li><li>在onPostExecuted()更新UI</li></ol></li><li>使用Handler实现异步任务<ol><li>在子线程中处理耗时操作</li><li>处理完成之后，通过handler.sendMessage()传递处理结果</li><li>在handler的handleMessage()方法中更新UI</li><li>或者使用handler.post()方法将消息放到Looper中</li></ol></li></ol><p>5、如何排查</p><ol><li>首先分析log</li><li>从trace.txt文件查看调用stack，adb pull data/anr/traces.txt ./mytraces.txt</li><li>看代码</li><li>仔细查看ANR的成因(iowait?block?memoryleak?)</li></ol><p>6、监测ANR的Watchdog</p><p>最近出来一个叫LeakCanary</p><p>#FC(Force Close)</p><p>##什么时候会出现</p><ol><li>Error</li><li>OOM，内存溢出</li><li>StackOverFlowError</li><li>Runtime,比如说空指针异常</li></ol><p>##解决的办法</p><ol><li>注意内存的使用和管理</li><li>使用Thread.UncaughtExceptionHandler接口</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ANR&quot;&gt;&lt;a href=&quot;#ANR&quot; class=&quot;headerlink&quot; title=&quot;#ANR&quot;&gt;&lt;/a&gt;#ANR&lt;/h2&gt;&lt;p&gt;1、ANR排错一般有三种类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;KeyDispatchTimeout(5 seconds) –主要是类型
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>APP启动过程</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/APP%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/APP启动过程/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="APP启动过程"><a href="#APP启动过程" class="headerlink" title="#APP启动过程"></a>#APP启动过程</h2><p><img src="http://7xntdm.com1.z0.glb.clouddn.com/activity_start_flow.png" alt></p><ul><li>上图就可以很好的说明App启动的过程</li><li>ActivityManagerService组织回退栈时以ActivityRecord为基本单位，所有的ActivityRecord放在同一个ArrayList里，可以将mHistory看作一个栈对象，索引0所指的对象位于栈底，索引mHistory.size()-1所指的对象位于栈顶</li><li>Zygote进程孵化出新的应用进程后，会执行ActivityThread类的main方法.在该方法里会先准备好Looper和消息队列，然后调用attach方法将应用进程绑定到ActivityManagerService，然后进入loop循环，不断地读取消息队列里的消息，并分发消息。</li><li>ActivityThread的main方法执行后,应用进程接下来通知ActivityManagerService应用进程已启动，ActivityManagerService保存应用进程的一个代理对象，这样ActivityManagerService可以通过这个代理对象控制应用进程，然后ActivityManagerService通知<strong>应用进程</strong>创建入口Activity的实例，并执行它的生命周期方法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;APP启动过程&quot;&gt;&lt;a href=&quot;#APP启动过程&quot; class=&quot;headerlink&quot; title=&quot;#APP启动过程&quot;&gt;&lt;/a&gt;#APP启动过程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xntdm.com1.z0.glb.clouddn.com/
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android关于OOM的解决方案</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Android%E5%85%B3%E4%BA%8Eoom%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/Android关于oom的解决方案/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:46:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android："><a href="#Android：" class="headerlink" title="#Android："></a>#Android：</h2><p>#Android关于OOM的解决方案</p><p>##OOM</p><ul><li>内存溢出（Out Of Memory）</li><li>也就是说内存占有量超过了VM所分配的最大</li></ul><p>##出现OOM的原因</p><ol><li>加载对象过大</li><li>相应资源过多，来不及释放</li></ol><p>##如何解决</p><ol><li>在内存引用上做些处理，常用的有软引用、强化引用、弱引用</li><li>在内存中加载图片时直接在内存中作处理，如边界压缩</li><li>动态回收内存</li><li>优化Dalvik虚拟机的堆内存分配</li><li>自定义堆内存大小</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android：&quot;&gt;&lt;a href=&quot;#Android：&quot; class=&quot;headerlink&quot; title=&quot;#Android：&quot;&gt;&lt;/a&gt;#Android：&lt;/h2&gt;&lt;p&gt;#Android关于OOM的解决方案&lt;/p&gt;
&lt;p&gt;##OOM&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android几种进程</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Android%E5%87%A0%E7%A7%8D%E8%BF%9B%E7%A8%8B/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/Android几种进程/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android："><a href="#Android：" class="headerlink" title="#Android："></a>#Android：</h2><h2 id="Android几种进程"><a href="#Android几种进程" class="headerlink" title="#Android几种进程"></a>#Android几种进程</h2><ol><li>前台进程：即与用户正在交互的Activity或者Activity用到的Service等，如果系统内存不足时前台进程是最后被杀死的</li><li>可见进程：可以是处于暂停状态(onPause)的Activity或者绑定在其上的Service，即被用户可见，但由于失去了焦点而不能与用户交互</li><li>服务进程：其中运行着使用startService方法启动的Service，虽然不被用户可见，但是却是用户关心的，例如用户正在非音乐界面听的音乐或者正在非下载页面自己下载的文件等；当系统要空间运行前两者进程时才会被终止</li><li>后台进程：其中运行着执行onStop方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的QQ，这样的进程系统一旦没了有内存就首先被杀死</li><li>空进程：不包含任何应用程序的程序组件的进程，这样的进程系统是一般不会让他存在的</li></ol><p>如何避免后台进程被杀死：</p><ol><li>调用startForegound，让你的Service所在的线程成为前台进程</li><li>Service的onStartCommond返回START_STICKY或START_REDELIVER_INTENT</li><li>Service的onDestroy里面重新启动自己</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android：&quot;&gt;&lt;a href=&quot;#Android：&quot; class=&quot;headerlink&quot; title=&quot;#Android：&quot;&gt;&lt;/a&gt;#Android：&lt;/h2&gt;&lt;h2 id=&quot;Android几种进程&quot;&gt;&lt;a href=&quot;#Android几种进程&quot; cla
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android图片中的三级缓存</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Android%E5%9B%BE%E7%89%87%E4%B8%AD%E7%9A%84%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/Android图片中的三级缓存/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:47:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android："><a href="#Android：" class="headerlink" title="#Android："></a>#Android：</h2><h2 id="Android图片中的三级缓存"><a href="#Android图片中的三级缓存" class="headerlink" title="#Android图片中的三级缓存"></a>#Android图片中的三级缓存</h2><p>##为什么要使用三级缓存</p><ul><li>如今的 Android App 经常会需要网络交互，通过网络获取图片是再正常不过的事了</li><li>假如每次启动的时候都从网络拉取图片的话，势必会消耗很多流量。在当前的状况下，对于非wifi用户来说，流量还是很贵的，一个很耗流量的应用，其用户数量级肯定要受到影响</li><li>特别是，当我们想要重复浏览一些图片时，如果每一次浏览都需要通过网络获取，流量的浪费可想而知</li><li>所以提出三级缓存策略，通过网络、本地、内存三级缓存图片，来减少不必要的网络交互，避免浪费流量</li></ul><p>##什么是三级缓存</p><ul><li>网络加载，不优先加载，速度慢，浪费流量</li><li>本地缓存，次优先加载，速度快</li><li>内存缓存，优先加载，速度最快</li></ul><p>##三级缓存原理</p><ul><li>首次加载 Android App 时，肯定要通过网络交互来获取图片，之后我们可以将图片保存至本地SD卡和内存中</li><li>之后运行 App 时，优先访问内存中的图片缓存，若内存中没有，则加载本地SD卡中的图片</li><li>总之，只在初次访问新内容时，才通过网络获取图片资源</li></ul><p>参考链接</p><p><a href="http://www.jianshu.com/p/2cd59a79ed4a" target="_blank" rel="noopener">http://www.jianshu.com/p/2cd59a79ed4a</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android：&quot;&gt;&lt;a href=&quot;#Android：&quot; class=&quot;headerlink&quot; title=&quot;#Android：&quot;&gt;&lt;/a&gt;#Android：&lt;/h2&gt;&lt;h2 id=&quot;Android图片中的三级缓存&quot;&gt;&lt;a href=&quot;#Android图片中的三
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android开机过程</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Android%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/Android开机过程/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:47:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android开机过程"><a href="#Android开机过程" class="headerlink" title="Android开机过程"></a>Android开机过程</h1><ul><li>BootLoder引导,然后加载Linux内核.</li><li>0号进程init启动.加载init.rc配置文件,配置文件有个命令启动了zygote进程</li><li>zygote开始fork出SystemServer进程</li><li>SystemServer加载各种JNI库,然后init1,init2方法,init2方法中开启了新线程ServerThread.</li><li>在SystemServer中会创建一个socket客户端，后续AMS（ActivityManagerService）会通过此客户端和zygote通信</li><li>ServerThread的run方法中开启了AMS,还孵化新进程ServiceManager,加载注册了一溜的服务,最后一句话进入loop 死循环</li><li>run方法的SystemReady调用resumeTopActivityLocked打开锁屏界面</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android开机过程&quot;&gt;&lt;a href=&quot;#Android开机过程&quot; class=&quot;headerlink&quot; title=&quot;Android开机过程&quot;&gt;&lt;/a&gt;Android开机过程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;BootLoder引导,然后加载Linux内核.&lt;/li
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android系统机制</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Android%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/Android系统机制/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android系统机制"><a href="#Android系统机制" class="headerlink" title="#Android系统机制"></a>#Android系统机制</h2><p>###APP启动过程</p><ol><li>Launcher线程捕获onclick的点击事件，调用Launcher.startActivitySafely，进一步调用Launcher.startActivity，最后调用父类Activity的startActivity。</li><li>Activity和ActivityManagerService交互，引入Instrumentation，将启动请求交给Instrumentation，调用Instrumentation.execStartActivity</li><li></li></ol><p>###Android内核解读-应用的安装过程</p><p><a href="http://blog.csdn.net/singwhatiwanna/article/details/19578947" target="_blank" rel="noopener">http://blog.csdn.net/singwhatiwanna/article/details/19578947</a><br>apk的安装过程分为两步：</p><ol><li>将apk文件复制到程序目录下(/data/app/)</li><li>为应用创建数据目录(/data/data/package name/)、提取dex文件到指定目录(/data/delvik-cache/)、修改系统包管理信息。</li></ol><p>###View的事件体系</p><p>###Handler消息机制</p><p>###AsyncTask<br>AyncTask是一个抽象类。</p><p>需要重写的方法有四个：</p><ol><li>onPreExecute()<br> 这个方法会在后台任务开始之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等</li><li>doInBackGround(Params…)<br> 在子线程中运行，不可更新UI，返回的是执行结果，第三个参数为Void不返回</li><li>onProgressUpdate(Progress…)<br> 利用参数可以进行UI操作。</li><li>onPostExecute(Result)<br> 返回的数据会作为参数传递到此方法中，可以利用返回的一些数据来进行一些UI操作。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onPreExecute() &#123;  </span><br><span class="line">        progressDialog.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected Boolean doInBackground(Void... params) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            while (true) &#123;  </span><br><span class="line">                int downloadPercent = doDownload();  </span><br><span class="line">                publishProgress(downloadPercent);  </span><br><span class="line">                if (downloadPercent &gt;= 100) &#123;  </span><br><span class="line">                    break;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onProgressUpdate(Integer... values) &#123;  </span><br><span class="line">        progressDialog.setMessage(&quot;当前下载进度：&quot; + values[0] + &quot;%&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onPostExecute(Boolean result) &#123;  </span><br><span class="line">        progressDialog.dismiss();  </span><br><span class="line">        if (result) &#123;  </span><br><span class="line">            Toast.makeText(context, &quot;下载成功&quot;, Toast.LENGTH_SHORT).show();  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            Toast.makeText(context, &quot;下载失败&quot;, Toast.LENGTH_SHORT).show();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动这个任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new DownloadTask().execute();</span><br></pre></td></tr></table></figure><p>###图片缓存机制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android系统机制&quot;&gt;&lt;a href=&quot;#Android系统机制&quot; class=&quot;headerlink&quot; title=&quot;#Android系统机制&quot;&gt;&lt;/a&gt;#Android系统机制&lt;/h2&gt;&lt;p&gt;###APP启动过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Launcher
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ART和Dalvik区别</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Art%E5%92%8CDalvik%E5%8C%BA%E5%88%AB/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/Art和Dalvik区别/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:48:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ART和Dalvik区别"><a href="#ART和Dalvik区别" class="headerlink" title="#ART和Dalvik区别"></a>#ART和Dalvik区别</h2><p>Art上应用启动快，运行快，但是耗费更多存储空间，安装时间长，总的来说ART的功效就是”空间换时间”。</p><p>ART: Ahead of Time Dalvik: Just in Time</p><p>什么是Dalvik：Dalvik是Google公司自己设计用于Android平台的Java虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一，它可以支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行，.dex格式是专为Dalvik应用设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为独立的Linux进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。</p><p>什么是ART:Android操作系统已经成熟，Google的Android团队开始将注意力转向一些底层组件，其中之一是负责应用程序运行的Dalvik运行时。Google开发者已经花了两年时间开发更快执行效率更高更省电的替代ART运行时。ART代表Android Runtime,其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time(JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装的时候就预编译字节码到机器语言，这一机制叫Ahead-Of-Time(AOT)编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。</p><p>ART优点：</p><ol><li>系统性能的显著提升</li><li>应用启动更快、运行更快、体验更流畅、触感反馈更及时</li><li>更长的电池续航能力</li><li>支持更低的硬件</li></ol><p>ART缺点：</p><ol><li>更大的存储空间占用，可能会增加10%-20%</li><li>更长的应用安装时间</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ART和Dalvik区别&quot;&gt;&lt;a href=&quot;#ART和Dalvik区别&quot; class=&quot;headerlink&quot; title=&quot;#ART和Dalvik区别&quot;&gt;&lt;/a&gt;#ART和Dalvik区别&lt;/h2&gt;&lt;p&gt;Art上应用启动快，运行快，但是耗费更多存储空间，安装时
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask源码分析</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Asynctask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/Asynctask源码分析/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="#AsyncTask"></a>#AsyncTask</h2><p>首先从Android3.0开始，系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做是为了避免主线程由于耗时操作所阻塞从而出现ANR现象。AsyncTask封装了线程池和Handler。AsyncTask有两个线程池：SerialExecutor和THREAD_POOL_EXECUTOR。前者是用于任务的排队，默认是串行的线程池：后者用于真正的执行任务。AsyncTask还有一个Handler，叫InternalHandler，用于将执行环境从线程池切换到主线程。AsyncTask内部就是通过InternalHandler来发送任务执行的进度以及执行结束等消息。</p><p>AsyncTask排队执行过程：系统先把参数Params封装为FutureTask对象，它相当于Runnable，接着FutureTask交给SerialExcutor的execute方法，它先把FutureTask插入到任务队列tasks中，如果这个时候没有正在活动的AsyncTask任务，那么就会执行下一个AsyncTask任务，同时当一个AsyncTask任务执行完毕之后，AsyncTask会继续执行其他任务直到所有任务都被执行为止。</p><hr><p>关于线程池，AsyncTask对应的线程池ThreadPoolExecutor都是进程范围内共享的，都是static的，所以是AsyncTask控制着进程范围内所有的子类实例。由于这个限制的存在，当使用默认线程池时，如果线程数超过线程池的最大容量，线程池就会爆掉(3.0默认串行执行，不会出现这个问题)。针对这种情况。可以尝试自定义线程池，配合AsyncTask使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AsyncTask&quot;&gt;&lt;a href=&quot;#AsyncTask&quot; class=&quot;headerlink&quot; title=&quot;#AsyncTask&quot;&gt;&lt;/a&gt;#AsyncTask&lt;/h2&gt;&lt;p&gt;首先从Android3.0开始，系统要求网络访问必须在子线程中进行，否则网络访问
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Binder机制</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Binder%E6%9C%BA%E5%88%B6/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/Binder机制/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:48:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Binder机制"><a href="#Binder机制" class="headerlink" title="#Binder机制"></a>#Binder机制</h2><p>首先Binder是Android系统进程间通信(IPC)方式之一。</p><p>Binder使用Client－Server通信方式。Binder框架定义了四个角色：Server,Client,ServiceManager以及Binder驱动。其中Server,Client,ServiceManager运行于用户空间，驱动运行于内核空间。Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信。</p><p>Server创建了Binder实体，为其取一个字符形式，可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给ServiceManager，通知ServiceManager注册一个名字为XX的Binder，它位于Server中。驱动为这个穿过进程边界的Binder创建位于内核中的实体结点以及ServiceManager对实体的引用，将名字以及新建的引用打包给ServiceManager。ServiceManager收数据包后，从中取出名字和引用填入一张查找表中。但是一个Server若向ServiceManager注册自己Binder就必须通过0这个引用和ServiceManager的Binder通信。Server向ServiceManager注册了Binder实体及其名字后，Client就可以通过名字获得该Binder的引用了。Clent也利用保留的0号引用向ServiceManager请求访问某个Binder：我申请名字叫XX的Binder的引用。ServiceManager收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder引用，将该引用作为回复发送给发起请求的Client。</p><p>当然，不是所有的Binder都需要注册给ServiceManager广而告之的。Server端可以通过已经建立的Binder连接将创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。由于这个Binder没有向ServiceManager注册名字，所以是匿名Binder。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。</p><hr><p>###为什么Binder只进行了一次数据拷贝？</p><p>Linux内核实际上没有从一个用户空间到另一个用户空间直接拷贝的函数，需要先用copy_from_user()拷贝到内核空间，再用copy_to_user()拷贝到另一个用户空间。为了实现用户空间到用户空间的拷贝，mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的‘秘密’。</p><p>最底层的是Android的ashmen(Anonymous shared memory)机制，它负责辅助实现内存的分配，以及跨进程所需要的内存共享。AIDL(android interface definition language)对Binder的使用进行了封装，可以让开发者方便的进行方法的远程调用，后面会详细介绍。Intent是最高一层的抽象，方便开发者进行常用的跨进程调用。</p><p>从英文字面上意思看，Binder具有粘结剂的意思那么它是把什么东西粘接在一起呢？在Android系统的Binder机制中，由一系统组件组成，分别是Client、Server、Service Manager和Binder驱动，其中Client、Server、Service Manager运行在用户空间，Binder驱动程序运行内核空间。Binder就是一种把这四个组件粘合在一起的粘连剂了，其中，核心组件便是Binder驱动程序了，ServiceManager提供了辅助管理的功能，Client和Server正是Binder驱动和ServiceManager提供的基础设施上，进行Client-Server之间的通信。</p><ol><li>Client、Server和ServiceManager实现在用户空间中，Binder驱动实现在内核空间中</li><li>Binder驱动程序和ServiceManager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server</li><li>Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和ServiceManager通过open和ioctl文件操作函数与Binder驱动程序进行通信</li><li>Client和Server之间的进程间通信通过Binder驱动程序间接实现</li><li>ServiceManager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力</li></ol><p>服务器端：一个Binder服务器就是一个Binder类的对象。当创建一个Binder对象后，内部就会开启一个线程，这个线程用户接收binder驱动发送的消息，收到消息后，会执行相关的服务代码。</p><p>Binder驱动：当服务端成功创建一个Binder对象后，Binder驱动也会相应创建一个mRemote对象，该对象的类型也是Binder类，客户就可以借助这个mRemote对象来访问远程服务。</p><p>客户端：客户端要想访问Binder的远程服务，就必须获取远程服务的Binder对象在binder驱动层对应的binder驱动层对应的mRemote引用。当获取到mRemote对象的引用后，就可以调用相应Binde对象的服务了。</p><p>在这里我们可以看到，客户是通过Binder驱动来调用服务端的相关服务。首先，在服务端创建一个Binder对象，接着客户端通过获取Binder驱动中Binder对象的引用来调用服务端的服务。在Binder机制中正是借着Binder驱动将不同进程间的组件bind(粘连)在一起，实现通信。</p><p>mmap将一个文件或者其他对象映射进内存。文件被映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会凋零。munmap执行相反的操作，删除特定地址区域的对象映射。</p><p>当使用mmap映射文件到进程后，就可以直接操作这段虚拟地址进行文件的读写等操作，不必再调用read,write等系统调用。但需注意，直接对该段内存写时不会写入超过当前文件大小的内容。</p><p>使用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次内存数据：一次从输入文件到共享内存区，另一次从共享内存到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域，而是保持共享区域，直到通信完成为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除内存映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p><p>aidl主要就帮助了我们完成了包装数据和解包的过程，并调用了transact过程，而用来传递的数据包我们就称为parcel</p><p>AIDL:xxx.aidl -&gt; xxx.java ,注册service</p><ol><li>用aidl定义需要被调用方法接口</li><li>实现这些方法</li><li>调用这些方法</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Binder机制&quot;&gt;&lt;a href=&quot;#Binder机制&quot; class=&quot;headerlink&quot; title=&quot;#Binder机制&quot;&gt;&lt;/a&gt;#Binder机制&lt;/h2&gt;&lt;p&gt;首先Binder是Android系统进程间通信(IPC)方式之一。&lt;/p&gt;
&lt;p&gt;Bin
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>EventBus用法详解</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/EventBus%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/EventBus用法详解/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EventBus"><a href="#EventBus" class="headerlink" title="#EventBus"></a>#EventBus</h2><p>###概述</p><p>EventBus是一款针对Android优化的发布/订阅（publish/subscribe）事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息。简化了应用程序内各组件间、组件与后台线程间的通信。优点是开销小，代码更优雅。以及将发送者和接收者解耦。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。</p><p>###EventBus作为一个消息总线，有三个主要的元素：</p><ul><li>Event：事件。可以是任意类型的对象</li><li>Subscriber：事件订阅者，接收特定的事件。在EventBus中，使用约定来指定事件订阅者以简化使用。即所有事件订阅都都是以onEvent开头的函数，具体来说，函数的名字是onEvent,onEventMainThread，onEventBackgroundThread，onEventAsync这四个，这个和<br>ThreadMode（下面讲）有关。</li><li>Publisher：事件发布者，用于通知 Subscriber 有事件发生。可以在任意线程任意位置发送事件，直接调用eventBus.post(Object) 方法，可以自己实例化 EventBus<br>对象，但一般使用默认的单例就好了：EventBus.getDefault()， 根据post函数参数的类型，会自动调用订阅相应类型事件的函数。</li></ul><p>###关于ThreadMode</p><p>前面说了，Subscriber的函数只能是那4个，因为每个事件订阅函数都是和一个ThreadMode相关联的，ThreadMode指定了会调用的函数。有以下四个ThreadMode：</p><ul><li>PostThread：事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程，而这个线程可能是UI线程。对应的函数名是onEvent。</li><li>MainThread: 事件的处理会在UI线程中执行。事件处理时间不能太长，这个不用说的，长了会ANR的，对应的函数名是onEventMainThread。</li><li>BackgroundThread：事件的处理会在一个后台线程中执行，对应的函数名是onEventBackgroundThread，虽然名字是BackgroundThread，事件处理是在后台线程，但事件处理时间还是不应该太长，因为如果发送事件的线程是后台线程，会直接执行事件，如果当前线程是UI线程，事件会被加到一个队列中，由一个线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理。</li><li>Async：事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程（有线程池），但最好限制线程的数目。</li></ul><p>根据事件订阅都函数名称的不同，会使用不同的ThreadMode，比如果在后台线程加载了数据想在UI线程显示，订阅者只需把函数命名onEventMainThread。</p><p>对相应的函数名，进一步解释一下：</p><p><strong>onEvent</strong>:如果使用onEvent作为订阅函数，那么该事件在哪个线程发布出来的，onEvent就会在这个线程中运行，也就是说发布事件和接收事件线程在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。</p><p><strong>onEventMainThread</strong>:如果使用onEventMainThread作为订阅函数，那么不论事件是在哪个线程中发布出来的，onEventMainThread都会在UI线程中执行，接收事件就会在UI线程中运行，这个在Android中是非常有用的，因为在Android中只能在UI线程中跟新UI，所以在onEvnetMainThread方法中是不能执行耗时操作的。</p><p><strong>onEventBackground</strong>:如果使用onEventBackgrond作为订阅函数，那么如果事件是在UI线程中发布出来的，那么onEventBackground就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么onEventBackground函数直接在该子线程中执行。</p><p><strong>onEventAsync</strong>：使用这个函数作为订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程在执行onEventAsync。</p><p>##基本用法</p><p>###引入EventBus:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;org.greenrobot:eventbus:3.0.0&apos;</span><br></pre></td></tr></table></figure><p>定义事件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class MessageEvent &#123; /* Additional fields if needed */ &#125;</span><br></pre></td></tr></table></figure><p>注册事件接收者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.register(this);</span><br></pre></td></tr></table></figure><p>发送事件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.post(event)</span><br></pre></td></tr></table></figure><p>接收消息并处理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 3.0后不再要求事件以 onEvent 开头，而是采用注解的方式</span><br><span class="line">@Subscribe(threadMode = ThreadMode.MAIN)</span><br><span class="line">public void receive(MessageEvent event)&#123;&#125;</span><br></pre></td></tr></table></figure><p>注销事件接收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.unregister(this);</span><br></pre></td></tr></table></figure><p>索引加速：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.0 后引入了索引加速(默认不开启)的功能，即通过 apt 编译插件的方式，在代码编译的时候对注解进行索引，避免了以往通过反射造成的性能损耗。</span><br><span class="line">如何使用可以参考[官方文档](http://greenrobot.org/eventbus/documentation/subscriber-index/)</span><br></pre></td></tr></table></figure><p>最后，proguard 需要做一些额外处理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#EventBus</span><br><span class="line"> -keepclassmembers class ** &#123;</span><br><span class="line">    public void onEvent*(**);</span><br><span class="line">    void onEvent*(**);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;EventBus&quot;&gt;&lt;a href=&quot;#EventBus&quot; class=&quot;headerlink&quot; title=&quot;#EventBus&quot;&gt;&lt;/a&gt;#EventBus&lt;/h2&gt;&lt;p&gt;###概述&lt;/p&gt;
&lt;p&gt;EventBus是一款针对Android优化的发布/订阅（pu
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ListView详解</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Listview%E8%AF%A6%E8%A7%A3/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/Listview详解/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:49:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ListView详解"><a href="#ListView详解" class="headerlink" title="#ListView详解"></a>#ListView详解</h2><p>直接继承自AbsListView，AbsListView继承自AdapterView，AdapterView又继承自ViewGroup。</p><p>Adpater在ListView和数据源之间起到了一个桥梁的作用</p><p>###RecycleBin机制</p><p>RecycleBin机制是ListView能够实现成百上千条数据都不会OOM最重要的一个原因。RecycleBin是AbsListView的一个内部类。</p><ul><li>RecycleBin当中使用mActiveViews这个数组来存储View，调用这个方法后就会根据传入的参数来将ListView中的指定元素存储到mActiveViews中。</li><li>mActiveViews当中所存储的View，一旦被获取了之后就会从mActiveViews当中移除，下次获取同样位置的时候将会返回null，所以mActiveViews不能被重复利用。</li><li>addScrapView()用于将一个废弃的View进行缓存，该方法接收一个View参数，当有某个View确定要废弃掉的时候（比如滚动出了屏幕）就应该调用这个方法来对View进行缓存，RecycleBin当中使用mScrapV</li><li>iews和mCurrentScrap这两个List来存储废弃View。</li><li>getScrapView 用于从废弃缓存中取出一个View，这些废弃缓存中的View是没有顺序可言的，因此getScrapView()方法中的算法也非常简单，就是直接从mCurrentScrap当中获取尾部的一个scrap view进行返回。</li><li>我们都知道Adapter当中可以重写一个getViewTypeCount()来表示ListView中有几种类型的数据项，而setViewTypeCount()方法的作用就是为每种类型的数据项都单独启用一个RecycleBin缓存机制。</li></ul><p>View的流程分三步，onMeasure()用于测量View的大小，onLayout()用于确定View的布局，onDraw()用于将View绘制到界面上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ListView详解&quot;&gt;&lt;a href=&quot;#ListView详解&quot; class=&quot;headerlink&quot; title=&quot;#ListView详解&quot;&gt;&lt;/a&gt;#ListView详解&lt;/h2&gt;&lt;p&gt;直接继承自AbsListView，AbsListView继承自Adapt
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Handler内存泄漏分析及解决</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Handler%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/Handler内存泄漏分析及解决/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:49:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Handler内存泄漏分析及解决"><a href="#Handler内存泄漏分析及解决" class="headerlink" title="#Handler内存泄漏分析及解决"></a>#Handler内存泄漏分析及解决</h2><p>###一、介绍</p><p>首先，请浏览下面这段handler代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SampleActivity extends Activity &#123;</span><br><span class="line">  private final Handler mLeakyHandler = new Handler() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">      // ... </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用handler时，这是一段很常见的代码。但是，它却会造成严重的内存泄漏问题。在实际编写中，我们往往会得到如下警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⚠ In Android, Handler classes should be static or leaks might occur.</span><br></pre></td></tr></table></figure><p>###二、分析</p><p>1、 Android角度</p><p>当Android应用程序启动时，framework会为该应用程序的主线程创建一个Looper对象。这个Looper对象包含一个简单的消息队列Message Queue，并且能够循环的处理队列中的消息。这些消息包括大多数应用程序framework事件，例如Activity生命周期方法调用、button点击等，这些消息都会被添加到消息队列中并被逐个处理。</p><p>另外，主线程的Looper对象会伴随该应用程序的整个生命周期。</p><p>然后，当主线程里，实例化一个Handler对象后，它就会自动与主线程Looper的消息队列关联起来。所有发送到消息队列的消息Message都会拥有一个对Handler的引用，所以当Looper来处理消息时，会据此回调[Handler#handleMessage(Message)]方法来处理消息。</p><p>2、 Java角度</p><p>在java里，非静态内部类 和 匿名类 都会潜在的引用它们所属的外部类。但是，静态内部类却不会。</p><p>###三、泄漏来源</p><p>请浏览下面一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SampleActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">  private final Handler mLeakyHandler = new Handler() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    // Post a message and delay its execution for 10 minutes.</span><br><span class="line">    mLeakyHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123; /* ... */ &#125;</span><br><span class="line">    &#125;, 1000 * 60 * 10);</span><br><span class="line"></span><br><span class="line">    // Go back to the previous Activity.</span><br><span class="line">    finish();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当activity结束(finish)时，里面的延时消息在得到处理前，会一直保存在主线程的消息队列里持续10分钟。而且，由上文可知，这条消息持有对handler的引用，而handler又持有对其外部类（在这里，即SampleActivity）的潜在引用。这条引用关系会一直保持直到消息得到处理，从而，这阻止了SampleActivity被垃圾回收器回收，同时造成应用程序的泄漏。</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>注意，上面代码中的Runnable类–非静态匿名类–同样持有对其外部类的引用。从而也导致泄漏。</p><p>=======<br>注意，上面代码中的Runnable类–非静态匿名类–同样持有对其外部类的引用。从而也导致泄漏。</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>c67abfcfd66909095068cb5f0c8632dc5547131b</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>###四、泄漏解决方案</p><p>首先，上面已经明确了内存泄漏来源：</p><p>只要有未处理的消息，那么消息会引用handler，非静态的handler又会引用外部类，即Activity，导致Activity无法被回收，造成泄漏；</p><p>Runnable类属于非静态匿名类，同样会引用外部类。</p><p>为了解决遇到的问题，我们要明确一点：静态内部类不会持有对外部类的引用。所以，我们可以把handler类放在单独的类文件中，或者使用静态内部类便可以避免泄漏。</p><p>另外，如果想要在handler内部去调用所在的外部类Activity，那么可以在handler内部使用弱引用的方式指向所在Activity，这样统一不会导致内存泄漏。</p><p>对于匿名类Runnable，同样可以将其设置为静态类。因为静态的匿名类不会持有对外部类的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class SampleActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Instances of static inner classes do not hold an implicit</span><br><span class="line">   * reference to their outer class.</span><br><span class="line">   */</span><br><span class="line">  private static class MyHandler extends Handler &#123;</span><br><span class="line">    private final WeakReference&lt;SampleActivity&gt; mActivity;</span><br><span class="line"></span><br><span class="line">    public MyHandler(SampleActivity activity) &#123;</span><br><span class="line">      mActivity = new WeakReference&lt;SampleActivity&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">      SampleActivity activity = mActivity.get();</span><br><span class="line">      if (activity != null) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private final MyHandler mHandler = new MyHandler(this);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Instances of anonymous classes do not hold an implicit</span><br><span class="line">   * reference to their outer class when they are &quot;static&quot;.</span><br><span class="line">   */</span><br><span class="line">  private static final Runnable sRunnable = new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123; /* ... */ &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    // Post a message and delay its execution for 10 minutes.</span><br><span class="line">    mHandler.postDelayed(sRunnable, 1000 * 60 * 10);</span><br><span class="line"></span><br><span class="line">    // Go back to the previous Activity.</span><br><span class="line">    finish();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###五、小结</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>虽然静态类与非静态类之间的区别并不大，但是对于Android开发者而言却是必须理解的。至少我们要清楚，如果一个内部类实例的生命周期比Activity更长，那么我们千万不要使用非静态的内部类。最好的做法是，使用静态内部类，然后在该类里使用弱引用来指向所在的Activity。</p><p>原文链接：</p><h1 id="http-www-jianshu-com-p-cb9b4b71a820"><a href="#http-www-jianshu-com-p-cb9b4b71a820" class="headerlink" title="http://www.jianshu.com/p/cb9b4b71a820"></a><a href="http://www.jianshu.com/p/cb9b4b71a820" target="_blank" rel="noopener">http://www.jianshu.com/p/cb9b4b71a820</a></h1><p>虽然静态类与非静态类之间的区别并不大，但是对于Android开发者而言却是必须理解的。至少我们要清楚，如果一个内部类实例的生命周期比Activity更长，那么我们千万不要使用非静态的内部类。最好的做法是，使用静态内部类，然后在该类里使用弱引用来指向所在的Activity。</p><p>原文链接：</p><p><a href="http://www.jianshu.com/p/cb9b4b71a820" target="_blank" rel="noopener">http://www.jianshu.com/p/cb9b4b71a820</a></p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>c67abfcfd66909095068cb5f0c8632dc5547131b</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Handler内存泄漏分析及解决&quot;&gt;&lt;a href=&quot;#Handler内存泄漏分析及解决&quot; class=&quot;headerlink&quot; title=&quot;#Handler内存泄漏分析及解决&quot;&gt;&lt;/a&gt;#Handler内存泄漏分析及解决&lt;/h2&gt;&lt;p&gt;###一、介绍&lt;/p&gt;

      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>MVC,MVP,MVVM的区别</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/MVC,MVP,MVVM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/MVC,MVP,MVVM的区别/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:49:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVC-MVP-MVVM的区别"><a href="#MVC-MVP-MVVM的区别" class="headerlink" title="#MVC,MVP,MVVM的区别"></a>#MVC,MVP,MVVM的区别</h2><p>#MVC<br>软件可以分为三部分</p><ul><li>视图（View）:用户界面</li><li>控制器（Controller）:业务逻辑</li><li>模型（Model）:数据保存</li></ul><p>各部分之间的通信方式如下：</p><ol><li>View传送指令到Controller</li><li>Controller完成业务逻辑后，要求Model改变状态</li><li>Model将新的数据发送到View，用户得到反馈</li></ol><p>Tips：所有的通信都是单向的。</p><p>#互动模式<br>接受用户指令时，MVC可以分为两种方式。一种是通过View接受指令，传递给Controller。</p><p>另一种是直接通过Controller接受指令</p><p>#MVP</p><p>MVP模式将Controller改名为Presenter，同时改变了通信方向。</p><ol><li>各部分之间的通信，都是双向的</li><li>View和Model不发生联系，都通过Presenter传递</li><li>View非常薄，不部署任何业务逻辑，称为”被动视图”(Passive View)，即没有任何主动性，而Presenter非常厚，所有逻辑都部署在那里。</li></ol><p>#MVVM</p><p>MVVM模式将Presenter改名为ViewModel，基本上与MVP模式完全一致。</p><p>唯一的区别是，它采用双向绑定(data-binding)：View的变动，自动反映在ViewModel，反之亦然。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MVC-MVP-MVVM的区别&quot;&gt;&lt;a href=&quot;#MVC-MVP-MVVM的区别&quot; class=&quot;headerlink&quot; title=&quot;#MVC,MVP,MVVM的区别&quot;&gt;&lt;/a&gt;#MVC,MVP,MVVM的区别&lt;/h2&gt;&lt;p&gt;#MVC&lt;br&gt;软件可以分为三部
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>MVP详解</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/MVP/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/MVP/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:49:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVP"><a href="#MVP" class="headerlink" title="#MVP"></a>#MVP</h2><p>###为什么需要MVP</p><ol><li>尽量简单<br> 大部分的安卓应用只使用View-Model结构,程序员现在更多的是和复杂的View打交道而不是解决业务逻辑。当你在应用中只使用Model-View时，到最后，你会发现“所有的事物都被连接到一起”。复杂的任务被分成细小的任务，并且很容易解决。越小的东西，bug越少，越容易debug，更好测试。在MVP模式下的View层将会变得简单，所以即便是他请求数据的时候也不需要回调函数。View逻辑变成十分直接。</li><li>后台任务<br> 当你编写一个Actviity、Fragment、自定义View的时候，你会把所有的和后台任务相关的方法写在一个静态类或者外部类中。这样，你的Task不再和Activity联系在一起，这既不会导致内存泄露，也不依赖于Activity的重建。</li></ol><p>###优缺点</p><p>优点：</p><ol><li>降低耦合度，实现了Model和View真正的完全分离，可以修改View而不影响Modle</li><li>模块职责划分明显，层次清晰</li><li>隐藏数据</li><li>Presenter可以复用，一个Presenter可以用于多个View，而不需要更改Presenter的逻辑（当然是在View的改动不影响业务逻辑的前提下）</li><li>利于测试驱动开发。以前的Android开发是难以进行单元测试的（虽然很多Android开发者都没有写过测试用例，但是随着项目变得越来越复杂，没有测试是很难保证软件质量的；而且近几年来Android上的测试框架已经有了长足的发展——开始写测试用例吧），在使用MVP的项目中Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。</li><li>View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。</li><li>代码灵活性</li></ol><p>缺点：</p><ol><li>Presenter中除了应用逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。</li><li>由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁。</li><li>如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么Presenter也需要变更了。</li><li>额外的代码复杂度及学习成本。</li></ol><p><strong>在MVP模式里通常包含4个要素：</strong></p><ol><li>View :负责绘制UI元素、与用户进行交互(在Android中体现为Activity);</li><li>View interface :需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试;</li><li>Model :负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合);</li><li>Presenter :作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MVP&quot;&gt;&lt;a href=&quot;#MVP&quot; class=&quot;headerlink&quot; title=&quot;#MVP&quot;&gt;&lt;/a&gt;#MVP&lt;/h2&gt;&lt;p&gt;###为什么需要MVP&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尽量简单&lt;br&gt; 大部分的安卓应用只使用View-Model结构,程序员现在更
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView和ListView的异同</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Recyclerview%E5%92%8CListview%E7%9A%84%E5%BC%82%E5%90%8C/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/Recyclerview和Listview的异同/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RecyclerView和ListView的异同"><a href="#RecyclerView和ListView的异同" class="headerlink" title="#RecyclerView和ListView的异同"></a>#RecyclerView和ListView的异同</h2><ul><li>ViewHolder是用来保存视图引用的类，无论是ListView亦或是RecyclerView。只不过在ListView中，ViewHolder需要自己来定义，且这只是一种推荐的使用方式，不使用当然也可以，这不是必须的。只不过不使用ViewHolder的话，ListView每次getView的时候都会调用findViewById(int)，这将导致ListView性能展示迟缓。而在RecyclerView中使用RecyclerView.ViewHolder则变成了必须，尽管实现起来稍显复杂，但它却解决了ListView面临的上述不使用自定义ViewHolder时所面临的问题。</li><li><p>我们知道ListView只能在垂直方向上滚动，Android API没有提供ListView在水平方向上面滚动的支持。或许有多种方式实现水平滑动，但是请想念我，ListView并不是设计来做这件事情的。但是RecyclerView相较于ListView，在滚动上面的功能扩展了许多。它可以支持多种类型列表的展示要求，主要如下：</p><ol><li>LinearLayoutManager，可以支持水平和竖直方向上滚动的列表。</li><li>StaggeredGridLayoutManager，可以支持交叉网格风格的列表，类似于瀑布流或者Pinterest。</li><li>GridLayoutManager，支持网格展示，可以水平或者竖直滚动，如展示图片的画廊。</li></ol></li><li><p>列表动画是一个全新的、拥有无限可能的维度。起初的Android API中，删除或添加item时，item是无法产生动画效果的。后面随着Android的进化，Google的Chat Hasse推荐使用ViewPropertyAnimator属性动画来实现上述需求。<br>相比较于ListView，RecyclerView.ItemAnimator则被提供用于在RecyclerView添加、删除或移动item时处理动画效果。同时，如果你比较懒，不想自定义ItemAnimator，你还可以使用DefaultItemAnimator。</p></li><li><p>ListView的Adapter中，getView是最重要的方法，它将视图跟position绑定起来，是所有神奇的事情发生的地方。同时我们也能够通过registerDataObserver在Adapter中注册一个观察者。RecyclerView也有这个特性，RecyclerView.AdapterDataObserver就是这个观察者。ListView有三个Adapter的默认实现，分别是ArrayAdapter、CursorAdapter和SimpleCursorAdapter。然而，RecyclerView的Adapter则拥有除了内置的内DB游标和ArrayList的支持之外的所有功能。RecyclerView.Adapter的实现的，我们必须采取措施将数据提供给Adapter，正如BaseAdapter对ListView所做的那样。</p></li><li><p>在ListView中如果我们想要在item之间添加间隔符，我们只需要在布局文件中对ListView添加如下属性即可：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:divider=&quot;@android:color/transparent&quot;</span><br><span class="line">android:dividerHeight=&quot;5dp&quot;</span><br></pre></td></tr></table></figure></li><li><p>ListView通过AdapterView.OnItemClickListener接口来探测点击事件。而RecyclerView则通过RecyclerView.OnItemTouchListener接口来探测触摸事件。它虽然增加了实现的难度，但是却给予开发人员拦截触摸事件更多的控制权限。</p></li><li><p>ListView可以设置选择模式，并添加MultiChoiceModeListener，如下所示：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);</span><br><span class="line">listView.setMultiChoiceModeListener(new MultiChoiceModeListener() &#123;</span><br><span class="line">    public boolean onCreateActionMode(ActionMode mode, Menu menu) &#123; ... &#125;</span><br><span class="line">    public void onItemCheckedStateChanged(ActionMode mode, int position,</span><br><span class="line">long id, boolean checked) &#123; ... &#125;</span><br><span class="line">    public boolean onActionItemClicked(ActionMode mode, MenuItem item) &#123;</span><br><span class="line">        switch (item.getItemId()) &#123;</span><br><span class="line">            case R.id.menu_item_delete_crime:</span><br><span class="line">            CrimeAdapter adapter = (CrimeAdapter)getListAdapter();</span><br><span class="line">            CrimeLab crimeLab = CrimeLab.get(getActivity());</span><br><span class="line">            for (int i = adapter.getCount() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                if (getListView().isItemChecked(i)) &#123;</span><br><span class="line">                    crimeLab.deleteCrime(adapter.getItem(i));</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        mode.finish();</span><br><span class="line">        adapter.notifyDataSetChanged();</span><br><span class="line">        return true;</span><br><span class="line">        default:</span><br><span class="line">            return false;</span><br><span class="line">&#125;</span><br><span class="line">    public boolean onPrepareActionMode(ActionMode mode, Menu menu) &#123; ... &#125;</span><br><span class="line">    public void onDestroyActionMode(ActionMode mode) &#123; ... &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  而RecyclerView则没有此功能。</p></li></ul><p><a href="http://www.cnblogs.com/littlepanpc/p/4497290.html" target="_blank" rel="noopener">http://www.cnblogs.com/littlepanpc/p/4497290.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RecyclerView和ListView的异同&quot;&gt;&lt;a href=&quot;#RecyclerView和ListView的异同&quot; class=&quot;headerlink&quot; title=&quot;#RecyclerView和ListView的异同&quot;&gt;&lt;/a&gt;#RecyclerView
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceView详解</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/SurfaceView/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/SurfaceView/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:50:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>##为什么要使用SurfaceView来实现动画？</p><p>###因为View的绘图存在以下缺陷：</p><ol><li>View缺乏双缓冲机制</li><li>当程序需要更新View上的图像时，程序必须重绘View上显示的整张图片</li><li>新线程无法直接更新View组件</li></ol><p>##SurfaceView的绘图机制</p><ul><li>一般会与SurfaceView结合使用</li><li>调用SurfaceView的getHolder()方法即可获得SurfaceView关联的SurfaceHolder</li></ul><p>##SurfaceHolder提供了如下方法来获取Canvas对象</p><ol><li>Canvas lockCanvas():锁定整个SurfaceView对象，获取该Surface上的Canvas</li><li>Canvas lockCanvas(Rect dirty):锁定SurfaceView上Rect划分的区域，获取该Surface上的Canvas</li><li>unlockCanvasAndPost(canvas):释放绘图、提交所绘制的图形，需要注意，当调用SurfaceHolder上的unlockCanvasAndPost方法之后，该方法之前所绘制的图形还处于缓冲之中，下一次lockCanvas()方法锁定的区域可能会“遮挡”它</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SurfaceViewTest extends Activity</span><br><span class="line">&#123;</span><br><span class="line">// SurfaceHolder负责维护SurfaceView上绘制的内容</span><br><span class="line">private SurfaceHolder holder;</span><br><span class="line">private Paint paint;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onCreate(Bundle savedInstanceState)</span><br><span class="line">&#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.main);</span><br><span class="line">paint = new Paint();</span><br><span class="line">SurfaceView surface = (SurfaceView) findViewById(R.id.show);</span><br><span class="line">// 初始化SurfaceHolder对象</span><br><span class="line">holder = surface.getHolder();</span><br><span class="line">holder.addCallback(new Callback()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2,</span><br><span class="line">int arg3)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void surfaceCreated(SurfaceHolder holder)</span><br><span class="line">&#123;</span><br><span class="line">// 锁定整个SurfaceView</span><br><span class="line">Canvas canvas = holder.lockCanvas();</span><br><span class="line">// 绘制背景</span><br><span class="line">Bitmap back = BitmapFactory.decodeResource(</span><br><span class="line">SurfaceViewTest.this.getResources()</span><br><span class="line">, R.drawable.sun);</span><br><span class="line">// 绘制背景</span><br><span class="line">canvas.drawBitmap(back, 0, 0, null);</span><br><span class="line">// 绘制完成，释放画布，提交修改</span><br><span class="line">holder.unlockCanvasAndPost(canvas);</span><br><span class="line">// 重新锁一次，&quot;持久化&quot;上次所绘制的内容</span><br><span class="line">holder.lockCanvas(new Rect(0, 0, 0, 0));</span><br><span class="line">holder.unlockCanvasAndPost(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void surfaceDestroyed(SurfaceHolder holder)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 为surface的触摸事件绑定监听器</span><br><span class="line">surface.setOnTouchListener(new OnTouchListener()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean onTouch(View source, MotionEvent event)</span><br><span class="line">&#123;</span><br><span class="line">// 只处理按下事件</span><br><span class="line">if (event.getAction() == MotionEvent.ACTION_DOWN)</span><br><span class="line">&#123;</span><br><span class="line">int cx = (int) event.getX();</span><br><span class="line">int cy = (int) event.getY();</span><br><span class="line">// 锁定SurfaceView的局部区域，只更新局部内容</span><br><span class="line">Canvas canvas = holder.lockCanvas(new Rect(cx - 50,</span><br><span class="line">cy - 50, cx + 50, cy + 50));</span><br><span class="line">// 保存canvas的当前状态</span><br><span class="line">canvas.save();</span><br><span class="line">// 旋转画布</span><br><span class="line">canvas.rotate(30, cx, cy);</span><br><span class="line">paint.setColor(Color.RED);</span><br><span class="line">// 绘制红色方块</span><br><span class="line">canvas.drawRect(cx - 40, cy - 40, cx, cy, paint);</span><br><span class="line">// 恢复Canvas之前的保存状态</span><br><span class="line">canvas.restore();</span><br><span class="line">paint.setColor(Color.GREEN);</span><br><span class="line">// 绘制绿色方块</span><br><span class="line">canvas.drawRect(cx, cy, cx + 40, cy + 40, paint);</span><br><span class="line">// 绘制完成，释放画布，提交修改</span><br><span class="line">holder.unlockCanvasAndPost(canvas);</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序为SurfaceHolder添加了一个CallBack实例，该Callback中定义了如下三个方法：</p><ul><li>void surfaceChanged(SurfaceHolder holder, int format, int width, int height):当一个surface的格式或大小发生改变时回调该方法。</li><li>void surfaceCreated(SurfaceHolder holder):当surface被创建时回调该方法</li><li>void surfaceDestroyed(SurfaceHolder holder):当surface将要被销毁时回调该方法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##为什么要使用SurfaceView来实现动画？&lt;/p&gt;
&lt;p&gt;###因为View的绘图存在以下缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;View缺乏双缓冲机制&lt;/li&gt;
&lt;li&gt;当程序需要更新View上的图像时，程序必须重绘View上显示的整张图片&lt;/li&gt;
&lt;li&gt;新线程无法
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>事件分发机制</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/事件分发机制/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:42:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android："><a href="#Android：" class="headerlink" title="#Android："></a>#Android：</h2><h1 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h1><hr><ul><li>对于一个根ViewGroup来说,发生点击事件首先调用dispatchTouchEvent</li><li>如果这个ViewGroup的onIterceptTouchEvent返回true就表示它要拦截当前事件,接着这个ViewGroup的onTouchEvent就会被调用.如果onIterceptTouchEvent返回false,那么就会继续向下调用子View的dispatchTouchEvent方法</li><li>当一个View需要处理事件的时候,如果它没有设置onTouchListener,那么直接调用onTouchEvent.如果设置了Listenter 那么就要看Listener的onTouch方法返回值.为true就不调,为false就调onTouchEvent</li><li>View的默认实现会在onTouchEvent里面把touch事件解析成Click之类的事件</li><li>点击事件传递顺序 Activity -&gt; Window -&gt; View</li><li>一旦一个元素拦截了某事件,那么一个事件序列里面后续的Move,Down事件都会交给它处理.并且它的onInterceptTouchEvent不会再调用</li><li>View的onTouchEvent默认都会消耗事件,除非它的clickable和longClickable都是false(不可点击),但是enable属性不会影响</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android：&quot;&gt;&lt;a href=&quot;#Android：&quot; class=&quot;headerlink&quot; title=&quot;#Android：&quot;&gt;&lt;/a&gt;#Android：&lt;/h2&gt;&lt;h1 id=&quot;事件分发机制&quot;&gt;&lt;a href=&quot;#事件分发机制&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>框架源码分析</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/开源框架源码分析/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:42:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android："><a href="#Android：" class="headerlink" title="#Android："></a>#Android：</h2><h2 id="框架源码分析"><a href="#框架源码分析" class="headerlink" title="#框架源码分析"></a>#框架源码分析</h2><h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="###Retrofit"></a>###Retrofit</h2><h2 id="EventBus"><a href="#EventBus" class="headerlink" title="###EventBus"></a>###EventBus</h2><h2 id="Glide"><a href="#Glide" class="headerlink" title="###Glide"></a>###Glide</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android：&quot;&gt;&lt;a href=&quot;#Android：&quot; class=&quot;headerlink&quot; title=&quot;#Android：&quot;&gt;&lt;/a&gt;#Android：&lt;/h2&gt;&lt;h2 id=&quot;框架源码分析&quot;&gt;&lt;a href=&quot;#框架源码分析&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>查漏补缺</title>
    <link href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>https://microcodor.github.io/2019/05/07/Android/Part1/Android/查漏补缺/</id>
    <published>2019-05-07T08:08:00.000Z</published>
    <updated>2019-05-07T08:42:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android："><a href="#Android：" class="headerlink" title="#Android："></a>#Android：</h2><h2 id="查漏补缺"><a href="#查漏补缺" class="headerlink" title="#查漏补缺"></a>#查漏补缺</h2><p>请分析一张400*500尺寸的PNG图片加载到程序中占用内存中的大小</p><p><a href="http://m.blog.csdn.net/article/details?id=7856519" target="_blank" rel="noopener">http://m.blog.csdn.net/article/details?id=7856519</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android：&quot;&gt;&lt;a href=&quot;#Android：&quot; class=&quot;headerlink&quot; title=&quot;#Android：&quot;&gt;&lt;/a&gt;#Android：&lt;/h2&gt;&lt;h2 id=&quot;查漏补缺&quot;&gt;&lt;a href=&quot;#查漏补缺&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Android" scheme="https://microcodor.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://microcodor.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
