<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>Activity启动过程全解析 | 程序员工作笔记</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="前端博客, 前端, 程序员, 前端开发, 全栈开发, react, javascript, Android"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Activity启动过程全解析/index.html"><link rel="icon" type="image/png" href="http://tva1.sinaimg.cn/crop.0.0.1002.1002.180/86cba9efjw8f3tsubs08fj20ru0rvq48.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="微码农"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(https://blog.static.minfive.com/other/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="微码农" alt="微码农"><img src="http://tva1.sinaimg.cn/crop.0.0.1002.1002.180/86cba9efjw8f3tsubs08fj20ru0rvq48.jpg" alt="微码农"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://upload-images.jianshu.io/upload_images/15405328-1ee675f13c8f7968?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="Activity启动过程全解析"></div><header class="post__info"><h1 class="post__title">Activity启动过程全解析</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://wxdroid.com">蜗牛</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2019-05-07</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Android/">Android</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><h2 id="Android："><a href="#Android：" class="headerlink" title="#Android："></a>#Android：</h2><h2 id="Activity启动过程"><a href="#Activity启动过程" class="headerlink" title="#Activity启动过程"></a>#Activity启动过程</h2><p>###一些基本的概念</p><ul><li>ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期</li><li>ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作</li><li>ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。</li><li>ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。</li><li>Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。</li><li>ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。</li><li>ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个* ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。</li><li>TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。</li></ul><p>###回答一些问题</p><p><strong>zygote是什么？有什么作用？</strong></p><p>zygote意为“受精卵“。Android是基于Linux系统的，而在Linux中，所有的进程都是由init进程直接或者是间接fork出来的，zygote进程也不例外。</p><p>在Android系统里面，zygote是一个进程的名字。Android是基于Linux System的，当你的手机开机的时候，Linux的内核加载完成之后就会启动一个叫“init“的进程。在Linux System里面，所有的进程都是由init进程fork出来的，我们的zygote进程也不例外。</p><p>我们都知道，每一个App其实都是</p><ul><li>一个单独的dalvik虚拟机</li><li>一个单独的进程</li></ul><p>所以当系统里面的第一个zygote进程运行之后，在这之后再开启App，就相当于开启一个新的进程。而为了实现资源共用和更快的启动速度，Android系统开启新进程的方式，是通过fork第一个zygote进程实现的。所以说，除了第一个zygote进程，其他应用所在的进程都是zygote的子进程，这下你明白为什么这个进程叫“受精卵”了吧？因为就像是一个受精卵一样，它能快速的分裂，并且产生遗传物质一样的细胞！</p><p><strong>SystemServer是什么？有什么作用？它与zygote的关系是什么？</strong></p><p>首先我要告诉你的是，SystemServer也是一个进程，而且是由zygote进程fork出来的。</p><p>知道了SystemServer的本质，我们对它就不算太陌生了，这个进程是Android Framework里面两大非常重要的进程之一——另外一个进程就是上面的zygote进程。</p><p>为什么说SystemServer非常重要呢？因为系统里面重要的服务都是在这个进程里面开启的，比如<br>ActivityManagerService、PackageManagerService、WindowManagerService等等，看着是不是都挺眼熟的？</p><p>那么这些系统服务是怎么开启起来的呢？</p><p>在zygote开启的时候，会调用ZygoteInit.main()进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line"></span><br><span class="line">     ...ignore some code...</span><br><span class="line"></span><br><span class="line">    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true</span><br><span class="line">     boolean startSystemServer = false;</span><br><span class="line">     for (int i = 1; i &lt; argv.length; i++) &#123;</span><br><span class="line">                if (&quot;start-system-server&quot;.equals(argv[i])) &#123;</span><br><span class="line">                    startSystemServer = true;</span><br><span class="line">                &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                    abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">                &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...ignore some code...</span><br><span class="line"></span><br><span class="line">         //开始fork我们的SystemServer进程</span><br><span class="line">     if (startSystemServer) &#123;</span><br><span class="line">                startSystemServer(abiList, socketName);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     ...ignore some code...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看下startSystemServer()做了些什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**留着这个注释，就是为了说明SystemServer确实是被fork出来的</span><br><span class="line"> * Prepare the arguments and fork for the system server process.</span><br><span class="line"> */</span><br><span class="line">private static boolean startSystemServer(String abiList, String socketName)</span><br><span class="line">        throws MethodAndArgsCaller, RuntimeException &#123;</span><br><span class="line"></span><br><span class="line">     ...ignore some code...</span><br><span class="line"></span><br><span class="line">    //留着这段注释，就是为了说明上面ZygoteInit.main(String argv[])里面的argv就是通过这种方式传递进来的</span><br><span class="line">    /* Hardcoded command line to start the system server */</span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        &quot;--setuid=1000&quot;,</span><br><span class="line">        &quot;--setgid=1000&quot;,</span><br><span class="line">        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007&quot;,</span><br><span class="line">        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,</span><br><span class="line">        &quot;--runtime-init&quot;,</span><br><span class="line">        &quot;--nice-name=system_server&quot;,</span><br><span class="line">        &quot;com.android.server.SystemServer&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int pid;</span><br><span class="line">    try &#123;</span><br><span class="line">        parsedArgs = new ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">    //确实是fuck出来的吧，我没骗你吧~不对，是fork出来的 -_-|||</span><br><span class="line">        /* Request to fork the system server process */</span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                null,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        throw new RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* For child process */</span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        if (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ActivityManagerService是什么？什么时候初始化的？有什么作用？</strong></p><p>ActivityManagerService，简称AMS，服务端对象，负责系统中所有Activity的生命周期。</p><p>ActivityManagerService进行初始化的时机很明确，就是在SystemServer进程开启的时候，就会初始化ActivityManagerService。从下面的代码中可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public final class SystemServer &#123;</span><br><span class="line"></span><br><span class="line">    //zygote的主入口</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemServer() &#123;</span><br><span class="line">        // Check for factory test mode.</span><br><span class="line">        mFactoryTestMode = FactoryTest.getMode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void run() &#123;</span><br><span class="line"></span><br><span class="line">        ...ignore some code...</span><br><span class="line"></span><br><span class="line">        //加载本地系统服务库，并进行初始化 </span><br><span class="line">        System.loadLibrary(&quot;android_servers&quot;);</span><br><span class="line">        nativeInit();</span><br><span class="line"></span><br><span class="line">        // 创建系统上下文</span><br><span class="line">        createSystemContext();</span><br><span class="line"></span><br><span class="line">        //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class&lt;T&gt;)，这个方法通过反射来启动对应的服务</span><br><span class="line">        mSystemServiceManager = new SystemServiceManager(mSystemContext);</span><br><span class="line"></span><br><span class="line">        //开启服务</span><br><span class="line">        try &#123;</span><br><span class="line">            startBootstrapServices();</span><br><span class="line">            startCoreServices();</span><br><span class="line">            startOtherServices();</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...ignore some code...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，并调用了Application.onCreate()。</span><br><span class="line">    private void createSystemContext() &#123;</span><br><span class="line">        ActivityThread activityThread = ActivityThread.systemMain();</span><br><span class="line">        mSystemContext = activityThread.getSystemContext();</span><br><span class="line">        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。</span><br><span class="line">    private void startBootstrapServices() &#123;</span><br><span class="line"></span><br><span class="line">        ...ignore some code...</span><br><span class="line"></span><br><span class="line">        //初始化ActivityManagerService</span><br><span class="line">        mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">                ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">        //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化</span><br><span class="line">        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line"></span><br><span class="line">        // 现在电源管理已经开启，ActivityManagerService负责电源管理功能</span><br><span class="line">        mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">        // 初始化DisplayManagerService</span><br><span class="line">        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line"></span><br><span class="line">    //初始化PackageManagerService</span><br><span class="line">    mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,</span><br><span class="line">       mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line"></span><br><span class="line">    ...ignore some code...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面这些步骤，我们的ActivityManagerService对象已经创建好了，并且完成了成员变量初始化。而且在这之前，调用createSystemContext()创建系统上下文的时候，也已经完成了mSystemContext和ActivityThread的创建。注意，这是系统进程开启时的流程，在这之后，会开启系统的Launcher程序，完成系统界面的加载与显示。</p><p>你是否会好奇，我为什么说AMS是服务端对象？下面我给你介绍下Android系统里面的服务器和客户端的概念。</p><p>其实服务器客户端的概念不仅仅存在于Web开发中，在Android的框架设计中，使用的也是这一种模式。服务器端指的就是所有App共用的系统服务，比如我们这里提到的ActivityManagerService，和前面提到的PackageManagerService、WindowManagerService等等，这些基础的系统服务是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你想打开一个App，那么我们知道了包名和MainActivity类名之后就可以打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(Intent.ACTION_MAIN);  </span><br><span class="line">intent.addCategory(Intent.CATEGORY_LAUNCHER);              </span><br><span class="line">ComponentName cn = new ComponentName(packageName, className);              </span><br><span class="line">intent.setComponent(cn);  </span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>但是，我们的App通过调用startActivity()并不能直接打开另外一个App，这个方法会通过一系列的调用，最后还是告诉AMS说：“我要打开这个App，我知道他的住址和名字，你帮我打开吧！”所以是AMS来通知zygote进程来fork一个新进程，来开启我们的目标App的。这就像是浏览器想要打开一个超链接一样，浏览器把网页地址发送给服务器，然后还是服务器把需要的资源文件发送给客户端的。</p><p>知道了Android Framework的客户端服务器架构之后，我们还需要了解一件事情，那就是我们的App和AMS(SystemServer进程)还有zygote进程分属于三个独立的进程，他们之间如何通信呢？</p><p>知道了Android Framework的客户端服务器架构之后，我们还需要了解一件事情，那就是我们的App和AMS(SystemServer进程)还有zygote进程分属于三个独立的进程，他们之间如何通信呢？</p><p>App与AMS通过Binder进行IPC通信，AMS(SystemServer进程)与zygote通过Socket进行IPC通信。</p><p>那么AMS有什么用呢？在前面我们知道了，如果想打开一个App的话，需要AMS去通知zygote进程，除此之外，其实所有的Activity的开启、暂停、关闭都需要AMS来控制，所以我们说，AMS负责系统中所有Activity的生命周期。</p><p>在Android系统中，任何一个Activity的启动都是由AMS和应用程序进程（主要是ActivityThread）相互配合来完成的。AMS服务统一调度系统中所有进程的Activity启动，而每个Activity的启动过程则由其所属的进程具体来完成。</p><p>这样说你可能还是觉得比较抽象，没关系，下面有一部分是专门来介绍AMS与ActivityThread如何一起合作控制Activity的生命周期的。</p><p><strong>Launcher是什么？什么时候启动的？</strong></p><p>当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。但是，你有没有思考过Launcher到底是一个什么东西？</p><p>Launcher本质上也是一个应用程序，和我们的App一样，也是继承自Activity</p><p>packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final class Launcher extends Activity</span><br><span class="line">        implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,</span><br><span class="line">                   View.OnTouchListener &#123;</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><p>Launcher实现了点击、长按等回调接口，来接收用户的输入。既然是普通的App，那么我们的开发经验在这里就仍然适用，比如，我们点击图标的时候，是怎么开启的应用呢？如果让你，你怎么做这个功能呢？捕捉图标点击事件，然后startActivity()发送对应的Intent请求呗！是的，Launcher也是这么做的，就是这么easy！</p><p>那么到底是处理的哪个对象的点击事件呢？既然Launcher是App，并且有界面，那么肯定有布局文件呀，是的，我找到了布局文件launcher.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:launcher=&quot;http://schemas.android.com/apk/res/com.android.launcher&quot;</span><br><span class="line">    android:id=&quot;@+id/launcher&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.android.launcher2.DragLayer</span><br><span class="line">        android:id=&quot;@+id/drag_layer&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Keep these behind the workspace so that they are not visible when</span><br><span class="line">             we go into AllApps --&gt;</span><br><span class="line">        &lt;include</span><br><span class="line">            android:id=&quot;@+id/dock_divider&quot;</span><br><span class="line">            layout=&quot;@layout/workspace_divider&quot;</span><br><span class="line">            android:layout_marginBottom=&quot;@dimen/button_bar_height&quot;</span><br><span class="line">            android:layout_gravity=&quot;bottom&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;include</span><br><span class="line">            android:id=&quot;@+id/paged_view_indicator&quot;</span><br><span class="line">            layout=&quot;@layout/scroll_indicator&quot;</span><br><span class="line">            android:layout_gravity=&quot;bottom&quot;</span><br><span class="line">            android:layout_marginBottom=&quot;@dimen/button_bar_height&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- The workspace contains 5 screens of cells --&gt;</span><br><span class="line">        &lt;com.android.launcher2.Workspace</span><br><span class="line">            android:id=&quot;@+id/workspace&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:paddingStart=&quot;@dimen/workspace_left_padding&quot;</span><br><span class="line">            android:paddingEnd=&quot;@dimen/workspace_right_padding&quot;</span><br><span class="line">            android:paddingTop=&quot;@dimen/workspace_top_padding&quot;</span><br><span class="line">            android:paddingBottom=&quot;@dimen/workspace_bottom_padding&quot;</span><br><span class="line">            launcher:defaultScreen=&quot;2&quot;</span><br><span class="line">            launcher:cellCountX=&quot;@integer/cell_count_x&quot;</span><br><span class="line">            launcher:cellCountY=&quot;@integer/cell_count_y&quot;</span><br><span class="line">            launcher:pageSpacing=&quot;@dimen/workspace_page_spacing&quot;</span><br><span class="line">            launcher:scrollIndicatorPaddingLeft=&quot;@dimen/workspace_divider_padding_left&quot;</span><br><span class="line">            launcher:scrollIndicatorPaddingRight=&quot;@dimen/workspace_divider_padding_right&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;include android:id=&quot;@+id/cell1&quot; layout=&quot;@layout/workspace_screen&quot; /&gt;</span><br><span class="line">            &lt;include android:id=&quot;@+id/cell2&quot; layout=&quot;@layout/workspace_screen&quot; /&gt;</span><br><span class="line">            &lt;include android:id=&quot;@+id/cell3&quot; layout=&quot;@layout/workspace_screen&quot; /&gt;</span><br><span class="line">            &lt;include android:id=&quot;@+id/cell4&quot; layout=&quot;@layout/workspace_screen&quot; /&gt;</span><br><span class="line">            &lt;include android:id=&quot;@+id/cell5&quot; layout=&quot;@layout/workspace_screen&quot; /&gt;</span><br><span class="line">        &lt;/com.android.launcher2.Workspace&gt;</span><br><span class="line"></span><br><span class="line">    ...ignore some code...</span><br><span class="line"></span><br><span class="line">    &lt;/com.android.launcher2.DragLayer&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure><p>为了方便查看，我删除了很多代码，从上面这些我们应该可以看出一些东西来：Launcher大量使用标签来实现界面的复用，而且定义了很多的自定义控件实现界面效果，dock_divider从布局的参数声明上可以猜出，是底部操作栏和上面图标布局的分割线，而paged_view_indicator则是页面指示器，和App首次进入的引导页下面的界面引导是一样的道理。当然，我们最关心的是Workspace这个布局，因为注释里面说在这里面包含了5个屏幕的单元格，想必你也猜到了，这个就是在首页存放我们图标的那五个界面(不同的ROM会做不同的DIY，数量不固定)。</p><p>接下来，我们应该打开workspace_screen布局，看看里面有什么东东。</p><p>workspace_screen.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.android.launcher2.CellLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:launcher=&quot;http://schemas.android.com/apk/res/com.android.launcher&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:paddingStart=&quot;@dimen/cell_layout_left_padding&quot;</span><br><span class="line">    android:paddingEnd=&quot;@dimen/cell_layout_right_padding&quot;</span><br><span class="line">    android:paddingTop=&quot;@dimen/cell_layout_top_padding&quot;</span><br><span class="line">    android:paddingBottom=&quot;@dimen/cell_layout_bottom_padding&quot;</span><br><span class="line">    android:hapticFeedbackEnabled=&quot;false&quot;</span><br><span class="line">    launcher:cellWidth=&quot;@dimen/workspace_cell_width&quot;</span><br><span class="line">    launcher:cellHeight=&quot;@dimen/workspace_cell_height&quot;</span><br><span class="line">    launcher:widthGap=&quot;@dimen/workspace_width_gap&quot;</span><br><span class="line">    launcher:heightGap=&quot;@dimen/workspace_height_gap&quot;</span><br><span class="line">    launcher:maxGap=&quot;@dimen/workspace_max_gap&quot; /&gt;</span><br></pre></td></tr></table></figure><p>里面就一个CellLayout，也是一个自定义布局，那么我们就可以猜到了，既然可以存放图标，那么这个自定义的布局很有可能是继承自ViewGroup或者是其子类，实际上，CellLayout确实是继承自ViewGroup。在CellLayout里面，只放了一个子View，那就是ShortcutAndWidgetContainer。从名字也可以看出来，ShortcutAndWidgetContainer这个类就是用来存放快捷图标和Widget小部件的，那么里面放的是什么对象呢？</p><p>在桌面上的图标，使用的是BubbleTextView对象，这个对象在TextView的基础之上，添加了一些特效，比如你长按移动图标的时候，图标位置会出现一个背景(不同版本的效果不同)，所以我们找到BubbleTextView对象的点击事件，就可以找到Launcher如何开启一个App了。</p><p>除了在桌面上有图标之外，在程序列表中点击图标，也可以开启对应的程序。这里的图标使用的不是BubbleTextView对象，而是PagedViewIcon对象，我们如果找到它的点击事件，就也可以找到Launcher如何开启一个App。</p><p>其实说这么多，和今天的主题隔着十万八千里，上面这些东西，你有兴趣就看，没兴趣就直接跳过，不知道不影响这篇文章阅读。</p><p>BubbleTextView的点击事件在哪里呢？我来告诉你：在Launcher.onClick(View v)里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Launches the intent referred by the clicked shortcut</span><br><span class="line">     */</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">          ...ignore some code...</span><br><span class="line"></span><br><span class="line">         Object tag = v.getTag();</span><br><span class="line">        if (tag instanceof ShortcutInfo) &#123;</span><br><span class="line">            // Open shortcut</span><br><span class="line">            final Intent intent = ((ShortcutInfo) tag).intent;</span><br><span class="line">            int[] pos = new int[2];</span><br><span class="line">            v.getLocationOnScreen(pos);</span><br><span class="line">            intent.setSourceBounds(new Rect(pos[0], pos[1],</span><br><span class="line">                    pos[0] + v.getWidth(), pos[1] + v.getHeight()));</span><br><span class="line">        //开始开启Activity咯~</span><br><span class="line">            boolean success = startActivitySafely(v, intent, tag);</span><br><span class="line"></span><br><span class="line">            if (success &amp;&amp; v instanceof BubbleTextView) &#123;</span><br><span class="line">                mWaitingForResume = (BubbleTextView) v;</span><br><span class="line">                mWaitingForResume.setStayPressed(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (tag instanceof FolderInfo) &#123;</span><br><span class="line">            //如果点击的是图标文件夹，就打开文件夹</span><br><span class="line">            if (v instanceof FolderIcon) &#123;</span><br><span class="line">                FolderIcon fi = (FolderIcon) v;</span><br><span class="line">                handleFolderClick(fi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (v == mAllAppsButton) &#123;</span><br><span class="line">        ...ignore some code...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们可以看到，在桌面上点击快捷图标的时候，会调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivitySafely(v, intent, tag);</span><br></pre></td></tr></table></figure><p>那么从程序列表界面，点击图标的时候会发生什么呢？实际上，程序列表界面使用的是AppsCustomizePagedView对象，所以我在这个类里面找到了onClick(View v)。</p><p>com.android.launcher2.AppsCustomizePagedView.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The Apps/Customize page that displays all the applications, widgets, and shortcuts.</span><br><span class="line"> */</span><br><span class="line">public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements</span><br><span class="line">        View.OnClickListener, View.OnKeyListener, DragSource,</span><br><span class="line">        PagedViewIcon.PressedCallback, PagedViewWidget.ShortPressListener,</span><br><span class="line">        LauncherTransitionable &#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">         ...ignore some code...</span><br><span class="line"></span><br><span class="line">        if (v instanceof PagedViewIcon) &#123;</span><br><span class="line">            mLauncher.updateWallpaperVisibility(true);</span><br><span class="line">            mLauncher.startActivitySafely(v, appInfo.intent, appInfo);</span><br><span class="line">        &#125; else if (v instanceof PagedViewWidget) &#123;</span><br><span class="line">                 ...ignore some code..</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;      </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到，调用的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLauncher.startActivitySafely(v, appInfo.intent, appInfo);</span><br></pre></td></tr></table></figure><p>殊途同归</p><p>不管从哪里点击图标，调用的都是Launcher.startActivitySafely()。</p><p>下面我们就可以一步步的来看一下Launcher.startActivitySafely()到底做了什么事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">boolean startActivitySafely(View v, Intent intent, Object tag) &#123;</span><br><span class="line">       boolean success = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           success = startActivity(v, intent, tag);</span><br><span class="line">       &#125; catch (ActivityNotFoundException e) &#123;</span><br><span class="line">           Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span><br><span class="line">           Log.e(TAG, &quot;Unable to launch. tag=&quot; + tag + &quot; intent=&quot; + intent, e);</span><br><span class="line">       &#125;</span><br><span class="line">       return success;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调用了startActivity(v, intent, tag)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">boolean startActivity(View v, Intent intent, Object tag) &#123;</span><br><span class="line"></span><br><span class="line">       intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">       try &#123;</span><br><span class="line">           boolean useLaunchAnimation = (v != null) &amp;&amp;</span><br><span class="line">                   !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);</span><br><span class="line"></span><br><span class="line">           if (useLaunchAnimation) &#123;</span><br><span class="line">               if (user == null || user.equals(android.os.Process.myUserHandle())) &#123;</span><br><span class="line">                   startActivity(intent, opts.toBundle());</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   launcherApps.startMainActivity(intent.getComponent(), user,</span><br><span class="line">                           intent.getSourceBounds(),</span><br><span class="line">                           opts.toBundle());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               if (user == null || user.equals(android.os.Process.myUserHandle())) &#123;</span><br><span class="line">                   startActivity(intent);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   launcherApps.startMainActivity(intent.getComponent(), user,</span><br><span class="line">                           intent.getSourceBounds(), null);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return true;</span><br><span class="line">       &#125; catch (SecurityException e) &#123;</span><br><span class="line">       ...</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里会调用Activity.startActivity(intent, opts.toBundle())，这个方法熟悉吗？这就是我们经常用到的Activity.startActivity(Intent)的重载函数。而且由于设置了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br></pre></td></tr></table></figure><p>所以这个Activity会添加到一个新的Task栈中，而且，startActivity()调用的其实是startActivityForResult()这个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">        if (options != null) &#123;</span><br><span class="line">            startActivityForResult(intent, -1, options);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Note we want to go through this call for compatibility with</span><br><span class="line">            // applications that may have overridden the method.</span><br><span class="line">            startActivityForResult(intent, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以我们现在明确了，Launcher中开启一个App，其实和我们在Activity中直接startActivity()基本一样，都是调用了Activity.startActivityForResult()。</p><p><strong>Instrumentation是什么？和ActivityThread是什么关系？</strong></p><p>还记得前面说过的Instrumentation对象吗？每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。当startActivityForResult()调用之后，实际上还是调用了mInstrumentation.execStartActivity()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123;</span><br><span class="line">        if (mParent == null) &#123;</span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            if (ar != null) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            ...ignore some code...    </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (options != null) &#123;</span><br><span class="line">                 //当现在的Activity有父Activity的时候会调用，但是在startActivityFromChild()内部实际还是调用的mInstrumentation.execStartActivity()</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode, options);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         ...ignore some code...    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是mInstrumentation.execStartActivity()的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">        IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">            ...ignore some code...</span><br><span class="line">      try &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess();</span><br><span class="line">            int result = ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以当我们在程序中调用startActivity()的 时候，实际上调用的是Instrumentation的相关的方法。</p><p>Instrumentation意为“仪器”，我们先看一下这个类里面包含哪些方法吧</p><p><img src="http://i11.tietuku.com/15eb948d37d9d4b3.png" alt></p><p>我们可以看到，这个类里面的方法大多数和Application和Activity有关，是的，这个类就是完成对Application和Activity初始化和生命周期的工具类。比如说，我单独挑一个callActivityOnCreate()让你看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">        prePerformCreate(activity);</span><br><span class="line">        activity.performCreate(icicle);</span><br><span class="line">        postPerformCreate(activity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对activity.performCreate(icicle);这一行代码熟悉吗？这一行里面就调用了传说中的Activity的入口函数onCreate()，不信？接着往下看</p><p>Activity.performCreate()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void performCreate(Bundle icicle) &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">        mActivityTransitionState.readState(icicle);</span><br><span class="line">        performCreateCommon();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没骗你吧，onCreate在这里调用了吧。但是有一件事情必须说清楚，那就是这个Instrumentation类这么重要，为啥我在开发的过程中，没有发现他的踪迹呢？</p><p>是的，Instrumentation这个类很重要，对Activity生命周期方法的调用根本就离不开他，他可以说是一个大管家，但是，这个大管家比较害羞，是一个女的，管内不管外，是老板娘~</p><p>那么你可能要问了，老板是谁呀？<br>老板当然是大名鼎鼎的ActivityThread了！</p><p>ActivityThread你都没听说过？那你肯定听说过传说中的UI线程吧？是的，这就是UI线程。我们前面说过，App和AMS是通过Binder传递信息的，那么ActivityThread就是专门与AMS的外交工作的。</p><p>AMS说：“ActivityThread，你给我暂停一个Activity！”<br>ActivityThread就说：“没问题！”然后转身和Instrumentation说：“老婆，AMS让暂停一个Activity，我这里忙着呢，你快去帮我把这事办了把~”<br>于是，Instrumentation就去把事儿搞定了。</p><p>所以说，AMS是董事会，负责指挥和调度的，ActivityThread是老板，虽然说家里的事自己说了算，但是需要听从AMS的指挥，而Instrumentation则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主ActivityThread的安排。</p><p><strong>如何理解AMS和ActivityThread之间的Binder通信？</strong></p><p>前面我们说到，在调用startActivity()的时候，实际上调用的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mInstrumentation.execStartActivity()</span><br></pre></td></tr></table></figure><p>但是到这里还没完呢！里面又调用了下面的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity</span><br></pre></td></tr></table></figure><div class="post-announce">感谢您的阅读，本文由 <a href="https://microcodor.github.io">微码农</a> 版权所有。如若转载，请注明出处：微码农（<a href="https://microcodor.github.io/2019/05/07/Android/Part1/Android/Activity启动过程全解析/">https://microcodor.github.io/2019/05/07/Android/Part1/Android/Activity启动过程全解析/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2019/05/07/Android/Part1/Android/插件化技术学习/" title="插件化技术学习"><i class="iconfont icon-prev"></i>插件化技术学习</a></div><div class="post__prev post__prev--right"><a href="/2019/05/07/Android/Part1/Android/Bitmap的分析与使用/" title="Bitmap的分析与使用">Bitmap的分析与使用<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/面试/">面试</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/博客/">博客</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/ReadingNotes/">ReadingNotes</a><span class="block-list-count">11</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Network/">Network</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/JavaSE/">JavaSE</a><span class="block-list-count">23</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/JVM/">JVM</a><span class="block-list-count">4</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Android/">Android</a><span class="block-list-count">60</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Algorithm/">Algorithm</a><span class="block-list-count">25</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2019/05/07/Android/Part1/Android/ANR问题/" title="ANR问题"><div class="item__cover"><img src="https://upload-images.jianshu.io/upload_images/15405328-1ee675f13c8f7968?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="ANR问题"></div><div class="item__info"><h3 class="item__title">ANR问题</h3><span class="item__text">2019-05-07</span></div></a></li><li class="latest-post-item"><a href="/2019/05/07/Android/Part1/Android/APP启动过程/" title="APP启动过程"><div class="item__cover"><img src="https://upload-images.jianshu.io/upload_images/15405328-1ee675f13c8f7968?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="APP启动过程"></div><div class="item__info"><h3 class="item__title">APP启动过程</h3><span class="item__text">2019-05-07</span></div></a></li><li class="latest-post-item"><a href="/2019/05/07/Android/Part1/Android/Android关于oom的解决方案/" title="Android关于OOM的解决方案"><div class="item__cover"><img src="https://upload-images.jianshu.io/upload_images/15405328-1ee675f13c8f7968?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="Android关于OOM的解决方案"></div><div class="item__info"><h3 class="item__title">Android关于OOM的解决方案</h3><span class="item__text">2019-05-07</span></div></a></li><li class="latest-post-item"><a href="/2019/05/07/Android/Part1/Android/Android几种进程/" title="Android几种进程"><div class="item__cover"><img src="https://upload-images.jianshu.io/upload_images/15405328-1ee675f13c8f7968?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="Android几种进程"></div><div class="item__info"><h3 class="item__title">Android几种进程</h3><span class="item__text">2019-05-07</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-item"><a class="tag-link" href="/tags/Android/">Android</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-item"><a class="tag-link" href="/tags/JVM/">JVM</a></li><li class="tag-item"><a class="tag-link" href="/tags/JavaSE/">JavaSE</a></li><li class="tag-item"><a class="tag-link" href="/tags/Network/">Network</a></li><li class="tag-item"><a class="tag-link" href="/tags/ReadingNotes/">ReadingNotes</a></li><li class="tag-item"><a class="tag-link" href="/tags/crontab/">crontab</a></li><li class="tag-item"><a class="tag-link" href="/tags/nginx/">nginx</a></li><li class="tag-item"><a class="tag-link" href="/tags/thinkphp5/">thinkphp5</a></li><li class="tag-item"><a class="tag-link" href="/tags/面试/">面试</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>BeiJing, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>920379777@qq.com</span></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://wxdroid.com" title="微码农外站" target="_blank">微码农</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/microcodor" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:920379777@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["Android"],gitalk=new Gitalk({clientID:"a2eaf80b18ad8401f697",clientSecret:"078b4ed3e989cb28234c0d1485dc788f94853985",repo:"microcodor.github.io",owner:"microcodor",admin:["microcodor"],labels:tags,id:new Date(155721648e4).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>